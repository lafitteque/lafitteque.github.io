<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }

        .instructions {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .key {
            background: #4CAF50;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="instructions">
        <p><a href="/"> &larr; Retour à la page d'acceuil du site</a></p>

        <h1>Implémentation de Dijkstra et sa visualisation étape par étape</h1>
        <h2>Contrôles :</h2>
        <div class="controls">
            <span class="key">W</span> Place des murs (maintenir clic)
            <span class="key">P</span> Place une personne (clic)
            <span class="key">T</span> Place la cible (clic)
            <span class="key">D</span> Efface une cellule (maintenir clic)
        </div>
        <div class="controls">
            <span class="key">B</span> Lance l'algorithme
            <span class="key">R</span> Reset la grille
        </div>
        <p><strong>Instructions :</strong> Placez d'abord une personne (P + clic), puis une cible (T + clic), enfin
            lancez avec B.</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>
    <script>
        // Variables globales - identiques à l'original
        let gridWidth = 25;
        let cellWidth = 40;
        let offset = 1;

        // Arrays et listes pour dijkstra
        let map; // Carte des distances
        let neighboursX = []; // listes des coordonnées X et Y pour les voisins
        let neighboursY = [];
        let lastLayerX = []; // listes des coordonnées X et Y pour la couche de voisins
        let lastLayerY = [];
        let pathX = []; // Listes contenant toutes les cellules du chemin
        let pathY = [];

        // Variables des personnes
        let persons;
        let maxPersons = 1;
        let prevIndexPerson = 0;
        let indexPerson = 0;
        let nextPerson = false;
        let indexPath = 0;
        let countPath = 0;
        let failed = false;

        let maxDistanceValue; // valeur maximale théorique possible pour une distance
        let neighboursNumber = 0; // pour savoir combien de voisins il y a
        let target = [-1, -1]; // coordonnées de la cible
        let mode = -1; // Pour savoir si on dessine des murs / personnes / cible ou si on supprime ou si on lance la simulation

        // Variables pour la gestion des touches
        let keyIsPressed = false;
        let currentKey = '';

        // // // // // // // // // // // 
        // // Algorithme PathFinding // //
        // // // // // // // // // // //

        function pathfindingDijkstra() {
            // quand nécessaire, on ajoute des voisins
            if (!nextPerson) {
                if (neighboursNumber === 0) {
                    addNeighbours();

                    // S'il n'y a plus de voisins, on termine l'algorithme pour cette personne
                    if (neighboursNumber === 0) {
                        failed = true;
                        nextPerson = true;
                    }
                }

                if (neighboursNumber !== 0) {
                    let x_ = neighboursX[0];
                    let y_ = neighboursY[0];

                    neighboursX.splice(0, 1);
                    neighboursY.splice(0, 1);
                    neighboursNumber--;

                    // Ensuite on calcule le poids de la distance de la personne à cette cellule
                    let m1 = maxDistanceValue;
                    let m2 = maxDistanceValue;
                    let m3 = maxDistanceValue;
                    let m4 = maxDistanceValue;

                    if (x_ - 1 >= 0 && map[x_ - 1][y_] !== -1) {
                        m1 = map[x_ - 1][y_];
                    }
                    if (y_ - 1 >= 0 && map[x_][y_ - 1] !== -1) {
                        m2 = map[x_][y_ - 1];
                    }
                    if (x_ + 1 < gridWidth && map[x_ + 1][y_] !== -1) {
                        m3 = map[x_ + 1][y_];
                    }
                    if (y_ + 1 < gridWidth && map[x_][y_ + 1] !== -1) {
                        m4 = map[x_][y_ + 1];
                    }

                    map[x_][y_] = Math.min(Math.min(m1, m2), Math.min(m3, m4)) + 1;

                    if (map[x_][y_] > maxDistanceValue) {
                        console.log(m1, m2, m3, m4);
                    }

                    if (x_ === target[0] && y_ === target[1]) {
                        nextPerson = true;
                        neighboursNumber = 0;
                    }
                }
            }
        }

        function addNeighbours() {
            let lastLayerSize = lastLayerX.length;
            for (let i = 0; i < lastLayerSize; i++) {
                for (let j = -1; j < 2; j += 2) {
                    // Voisins à gauche/droite de la cellule
                    let x_ = lastLayerX[i] + j;
                    let y_ = lastLayerY[i];
                    let inBounds = x_ >= 0 && x_ < gridWidth && y_ >= 0 && y_ < gridWidth;

                    if (inBounds) {
                        if (map[x_][y_] === maxDistanceValue) {
                            if (!isInNeighbours(x_, y_)) {
                                lastLayerX.push(x_);
                                lastLayerY.push(y_);
                                neighboursX.push(x_);
                                neighboursY.push(y_);
                                neighboursNumber++;
                            }
                        }
                    }

                    // Voisins au-dessus/en-dessous de la cellule
                    x_ = lastLayerX[i];
                    y_ = lastLayerY[i] + j;
                    inBounds = x_ >= 0 && x_ < gridWidth && y_ >= 0 && y_ < gridWidth;

                    if (inBounds) {
                        if (map[x_][y_] === maxDistanceValue) {
                            if (!isInNeighbours(x_, y_)) {
                                lastLayerX.push(x_);
                                lastLayerY.push(y_);
                                neighboursX.push(x_);
                                neighboursY.push(y_);
                                neighboursNumber++;
                            }
                        }
                    }
                }
            }

            // Supprime les éléments de la couche précédente
            for (let i = 0; i < lastLayerSize; i++) {
                lastLayerX.splice(0, 1);
                lastLayerY.splice(0, 1);
            }
        }

        function drawPath() {
            if (indexPath === 0) {
                pathX.push(target[0]);
                pathY.push(target[1]);
                countPath = 0;
            }

            let x_ = pathX[indexPath];
            let y_ = pathY[indexPath];

            countPath++;
            indexPath++;

            let d = map[target[0]][target[1]];

            if (x_ - 1 >= 0 && map[x_ - 1][y_] === d - countPath) {
                x_ -= 1;
            }
            else if (y_ - 1 >= 0 && map[x_][y_ - 1] === d - countPath) {
                y_ -= 1;
            }
            else if (x_ + 1 < gridWidth && map[x_ + 1][y_] === d - countPath) {
                x_ += 1;
            }
            else if (y_ + 1 < gridWidth && map[x_][y_ + 1] === d - countPath) {
                y_ += 1;
            }

            pathX.push(x_);
            pathY.push(y_);
        }

        function isInNeighbours(x_, y_) {
            let count = 0;
            while (count < neighboursNumber) {
                if (neighboursX[count] === x_ && neighboursY[count] === y_) {
                    return true;
                }
                count++;
            }
            return false;
        }

        // // // // // // // // // // // // // // 
        // // Initialisation et boucle principale // //
        // // // // // // // // // // // // // 

        function setup() {
            createCanvas(1000, 1000);
            background(50);
            init();
        }

        function init() {
            neighboursX = [];
            neighboursY = [];
            lastLayerX = [];
            lastLayerY = [];
            pathX = [];
            pathY = [];

            neighboursNumber = 0;
            indexPath = 0;
            maxDistanceValue = gridWidth * gridWidth;

            target[0] = -1;
            target[1] = -1;

            persons = [];
            for (let i = 0; i < maxPersons; i++) {
                persons.push([-1, -1]);
            }

            map = [];
            for (let i = 0; i < gridWidth; i++) {
                map[i] = [];
                for (let j = 0; j < gridWidth; j++) {
                    map[i][j] = maxDistanceValue;
                }
            }

            indexPerson = 0;
            failed = false;
            nextPerson = false;
            countPath = 0;

            drawCells();
        }

        // Boucle principale - Gère les modes
        function draw() {
            // Gestion des modes
            if (mode === 0) {
                placeWall();
            }
            if (mode === 1) {
                placePerson();
            }
            if (mode === 2) {
                placeTarget();
            }
            if (mode === 3) {
                deleteCell();
            }
            if (mode === 4) {
                // Lance la simulation
                if (!nextPerson && indexPerson < maxPersons) {
                    pathfindingDijkstra();
                }
                else if (!failed && indexPerson < maxPersons && target[0] !== -1 && target[1] !== -1) {
                    if (map[target[0]][target[1]] < maxDistanceValue && indexPath < map[target[0]][target[1]]) {
                        drawPath();
                    } else {
                        // Chemin terminé, arrêter l'algorithme
                        mode = -1;
                        console.log("Chemin trouvé et affiché !");
                    }
                }
                else {
                    failed = false;
                    nextPerson = false;
                    indexPerson++;
                    if (indexPerson >= maxPersons) {
                        mode = -1; // Arrêter l'algorithme
                        console.log("Algorithme terminé");
                    }
                }
            }

            drawCells();
        }

        // // // // // // // // // // // // // // // // // //
        // // // // // // Tous les modes possibles // // // // // 
        // // // // // // // // // // // // // // // // // 

        function placeWall() {
            if (mouseIsPressed) {
                let gridX = Math.floor(mouseX / cellWidth);
                let gridY = Math.floor(mouseY / cellWidth);
                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridWidth) {
                    map[gridX][gridY] = -1;
                }
            }
        }

        let personPlaced = false;

        function placePerson() {
            if (mouseIsPressed && !personPlaced) {
                let gridX = Math.floor(mouseX / cellWidth);
                let gridY = Math.floor(mouseY / cellWidth);
                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridWidth) {
                    if (lastLayerX.length > 0) {
                        map[lastLayerX[0]][lastLayerY[0]] = maxDistanceValue;
                        lastLayerX.splice(0, 1);
                        lastLayerY.splice(0, 1);
                    }

                    map[gridX][gridY] = 0;
                    persons[indexPerson][0] = gridX;
                    persons[indexPerson][1] = gridY;

                    lastLayerX.push(gridX);
                    lastLayerY.push(gridY);

                    indexPerson = (indexPerson + 1) % maxPersons;
                    personPlaced = true;
                }
            }
            if (!mouseIsPressed) {
                personPlaced = false;
            }
        }

        let targetPlaced = false;

        function placeTarget() {
            if (mouseIsPressed && !targetPlaced) {
                let gridX = Math.floor(mouseX / cellWidth);
                let gridY = Math.floor(mouseY / cellWidth);
                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridWidth) {
                    target[0] = gridX;
                    target[1] = gridY;
                    targetPlaced = true;
                }
            }
            if (!mouseIsPressed) {
                targetPlaced = false;
            }
        }

        function deleteCell() {
            if (mouseIsPressed) {
                let gridX = Math.floor(mouseX / cellWidth);
                let gridY = Math.floor(mouseY / cellWidth);
                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridWidth) {
                    map[gridX][gridY] = maxDistanceValue;
                }
            }
        }

        // // // // // // // // // // // // // 
        // // Fonctions pour dessiner les cellules // // 
        // // // // // // // // // // // // // 

        function drawCells() {
            background(50);
            for (let i = 0; i < gridWidth; i++) {
                for (let j = 0; j < gridWidth; j++) {
                    drawCell(i, j);
                }
            }
            drawPersons();
            drawTarget();
        }

        function drawCell(i, j) {
            // Quand on connaît le chemin le plus court, on le dessine
            if (pathX.length > 0) {
                for (let k = 0; k < pathX.length; k++) {
                    if (i === pathX[k] && j === pathY[k]) {
                        push();
                        noStroke();
                        fill(0, 200, 0);
                        rect(i * cellWidth + offset, j * cellWidth + offset, cellWidth - 2 * offset, cellWidth - 2 * offset);
                        pop();
                        return;
                    }
                }
            }

            // Quand une cellule n'a pas été explorée et n'est pas un mur, on la dessine en blanc
            if (map[i][j] === maxDistanceValue) {
                push();
                noStroke();
                fill(255);
                rect(i * cellWidth + offset, j * cellWidth + offset, cellWidth - 2 * offset, cellWidth - 2 * offset);
                pop();
            }
            // Si une cellule a été explorée, on dessine et écrit la distance de la personne dessus
            else if (map[i][j] > 0) {
                push();
                noStroke();
                fill(0, 150, 150);
                rect(i * cellWidth + offset, j * cellWidth + offset, cellWidth - 2 * offset, cellWidth - 2 * offset);
                pop();

                push();
                fill(255);
                textAlign(CENTER, CENTER);
                textSize(12);
                text(map[i][j], i * cellWidth + cellWidth / 2, j * cellWidth + cellWidth / 2);
                pop();
            }
            // Si la valeur est -1, on dessine une cellule noire (mur)
            else {
                push();
                noStroke();
                fill(0);
                rect(i * cellWidth + offset, j * cellWidth + offset, cellWidth - 2 * offset, cellWidth - 2 * offset);
                pop();
            }
        }

        function drawPersons() {
            let count = 0;
            while (count < maxPersons && persons[count][0] !== -1) {
                push();
                noStroke();
                fill(0, 0, 255);
                rect(persons[count][0] * cellWidth + offset, persons[count][1] * cellWidth + offset,
                    cellWidth - 2 * offset, cellWidth - 2 * offset);
                pop();
                count++;
            }
        }

        function drawTarget() {
            if (target[0] !== -1 && target[1] !== -1) {
                push();
                noStroke();
                fill(255, 0, 0);
                rect(target[0] * cellWidth + offset, target[1] * cellWidth + offset,
                    cellWidth - 2 * offset, cellWidth - 2 * offset);
                pop();
            }
        }

        // Gestion des événements
        function keyPressed() {
            if (key === 'w' || key === 'W') {
                mode = 0;
                console.log("Mode mur activé");
            }
            if (key === 'p' || key === 'P') {
                mode = 1;
                console.log("Mode personne activé");
            }
            if (key === 't' || key === 'T') {
                mode = 2;
                console.log("Mode cible activé");
            }
            if (key === 'd' || key === 'D') {
                mode = 3;
                console.log("Mode suppression activé");
            }
            if (key === 'b' || key === 'B') {
                if (persons[0][0] !== -1 && target[0] !== -1) {
                    mode = 4;
                    // Reset des variables pour l'algorithme
                    failed = false;
                    nextPerson = false;
                    indexPerson = 0;
                    indexPath = 0;
                    countPath = 0;
                    pathX = [];
                    pathY = [];
                    neighboursX = [];
                    neighboursY = [];
                    neighboursNumber = 0;

                    // Réinitialise la carte sauf les murs
                    for (let x = 0; x < gridWidth; x++) {
                        for (let y = 0; y < gridWidth; y++) {
                            if (map[x][y] !== -1) {
                                map[x][y] = maxDistanceValue;
                            }
                        }
                    }

                    // Place la personne comme point de départ (distance 0)
                    map[persons[0][0]][persons[0][1]] = 0;
                    lastLayerX = [persons[0][0]];
                    lastLayerY = [persons[0][1]];

                    console.log("Algorithme lancé");
                } else {
                    console.log("Placez d'abord une personne et une cible!");
                }
            }
            if (key === 'r' || key === 'R') {
                init();
                mode = -1;
                console.log("Reset effectué");
            }
        }
    </script>
</body>

</html>