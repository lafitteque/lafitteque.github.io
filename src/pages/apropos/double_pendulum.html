<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }

        .instructions {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .key {
            background: #4CAF50;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="instructions">
        <p><a href="/"> &larr; Retour Ã  la page d'acceuil du site</a></p>

        <h1>Simulation d'un double pendule (sans frotements)</h1>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/p5@1.1.9/lib/p5.js"></script>
    <script>

        // Simulation of a double pendulum, two pendulums are connnected (each one with a mass at its end).
        // Angles (rad)
        var a1 = 3.1415 / 2;
        var a2 = 3.1415 / 3; // Angular Velocities (rad.s-1)
        var a1_v = 0;
        var a2_v = 0; // Angular Accelerations (rad.s-2)
        var a1_a = 0;
        var a2_a = 0; // radius
        var r1 = 200;
        var r2 = 200; // masses
        var m1 = 10;
        var m2 = 2;
        var deltaT = 0.1; // Time interval
        var g = 9.8; // Gravity
        //Screen parameters
        var screenWidth = 900;
        var topOffset = 400; // Memory variables
        var pointsNumber = 500;
        var index = 0;
        var points; // positions
        var x1;
        var y1;
        var x2;
        var y2;
        var canvas;

        function setup() {
            points = [] // We want all our points in memory to be outside of the screen at the beginning so we can't see them
            for (var i = 0; i < pointsNumber; i++) {
                points.push([-100, -100]);
            } // We use two layers in order to simplify the drawing of the points in memory
            createCanvas(900, 900);
            background(20);
        }
        function draw() {
            iterateState();
            actualizeMemory();
            drawMemory();
            drawPendulum();

        }
        function iterateState() {
            // The equations were found at  https://www.myphysicslab.com/pendulum/double-pendulum-en.html (after eq (16))
            var num1 = -g * (2 * m1 + m2) * sin(a1);
            var num2 = -m2 * g * sin(a1 - 2 * a2);
            var num3 = -2 * sin(a1 - a2) * m2;
            var num4 = a2_v * a2_v * r2 + a1_v * r1 * cos(a1 - a2);
            var den = r1 * (2 * m1 + m2 - m2 * cos(2 * a1 - 2 * a2));
            a1_a = num1 + num2 + num3 * num4;
            a1_a /= den;
            num1 = 2 * sin(a1 - a2);
            num2 = a1_v * a1_v * r1 * (m1 + m2);
            num3 = g * (m1 + m2) * cos(a1);
            num4 = a2_v * a2_v * r2 * m2 * cos(a1 - a2);
            den = r2 * (2 * m1 + m2 - m2 * cos(2 * a1 - 2 * a2));
            a2_a = (num1 * (num2 + num3 + num4)) / den; // Angular Velocity (rad.s-1)
            a1_v += deltaT * a1_a;
            a2_v += deltaT * a2_a; // Desceleration
            a1_v -= a1_v * 0.002; // which is compvarely equivalent to a_v *= 0.998 but for physical interpretation it is clearer to write it this way
            a2_v -= a1_v * 0.002; // Angle
            a1 += deltaT * a1_v;
            a2 += deltaT * a2_v; // Positions
            x1 = screenWidth / 2 + r1 * cos(a1 + PI / 2);
            y1 = topOffset + r1 * sin(a1 + PI / 2);
            x2 = x1 + r2 * cos(a2 + PI / 2);
            y2 = y1 + r2 * sin(a2 + PI / 2);
        }
        function actualizeMemory() {
            points[index][0] = x2;
            points[index][1] = y2;
            index = (index + 1) % pointsNumber;
        }
        function drawPendulum() {
            // Drawing the two lines of the pendulum
            stroke(220, 100, 100);
            line(screenWidth / 2, topOffset, x1, y1);
            line(x1, y1, x2, y2); // Drawing two circles depending on the masses (we are in 2D so I chose the square root to calculate the radius)
            var l1 = sqrt(m1);
            var l2 = sqrt(m2);
            fill(250, 200, 200);
            ellipse(screenWidth / 2, topOffset, 5, 5);
            noStroke();
            fill(220, 100, 100);
            ellipse(x1, y1, 2 * l1, 2 * l1);
            noStroke();
            fill(220, 100, 100);
            ellipse(x2, y2, 2 * l2, 2 * l2);
        }
        function drawMemory() {
            // Drawing the previous points depending on the time spent since their appearance
            background(20);
            for (var i = 0; i < pointsNumber; i++) {
                // If there are two points on top of each other, we want the brightest to be shown, so we first draw the darkest ones,
                // so we go in the increasing order , beginning at the actual index (wich points to the last point)
                var drawMemoryIndex = (i + index - 1 + pointsNumber) % pointsNumber;
                strokeWeight(8 - (4 * (i + 1)) / pointsNumber);
                stroke(max(20, (255 * (i + 1)) / pointsNumber));
                point(points[drawMemoryIndex][0], points[drawMemoryIndex][1]);
            }

        }

    </script>